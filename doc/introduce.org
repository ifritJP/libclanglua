# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold

* Lua で C/C++ の構文解析

ここでは [[https://github.com/ifritJP/libclanglua][libclanglua]] を使って Lua から C/C++ の構文解析を行なう方法を紹介します。

libclanglua は libclang の Lua 用 binding です。

以降は、 libclanglua のテスト用サンプル [[https://github.com/ifritJP/libclanglua/blob/master/src/test.lua][test.lua]] の内容について説明します。

なお、この test.lua を利用し、
解析対象のテストコード [[https://github.com/ifritJP/libclanglua/blob/master/src/test/hoge.cpp][hoge.cpp]] を解析した結果が [[https://github.com/ifritJP/libclanglua/blob/master/src/test-result.expect][test-result.expect]] となります。

libclanglua を使用して C/C++ で書いたソースコードを構文解析した情報を利用することで、
さまざまな用途に活用できます。

その活用例として、ソースコードタグシステム [[https://github.com/ifritJP/lctags][lctags]] を開発しています。


** require

まずは require で libclanglua をロードします。
   
#+BEGIN_SRC Lua
local clang = require( 'libclanglua.if' )
#+END_SRC

以降 libclanglua モジュールは、clang として扱います。

** index

解析するために、まずは index を生成します。

#+BEGIN_SRC Lua
local clangIndex = clang.createIndex( 0, 1 )
#+END_SRC

** 解析

index を使用して C ソースを解析します。

#+BEGIN_SRC Lua
local options = { "-Iinc", "-DDEF" }
local args = clang.mkcharPArray( options )
local transUnit = clangIndex:createTranslationUnitFromSourceFile(
      "hoge.cpp", args:getLength(), args:getPtr(), 0, nil );
#+END_SRC

options には、コンパイルオプション文字列配列を指定します。
コンパイルオプションは clang のコンパイルオプションを指定する必要があります。
clang のコンパイルオプションは、多くの場合 gcc と互換があります。

clang.mkcharPArray() は、
Lua の文字列配列(テーブル)から libclang に渡す文字列配列型データを生成する関数です。

clangIndex:createTranslationUnitFromSourceFile() は、
ソース hoge.cpp をコンパイルオプション arg で構文解析し、
TranslationUnit を返します。

なお、clangIndex:createTranslationUnitFromSourceFile() の第 4、5 引数は、
解析対象のファイル情報を渡します。
指定しない場合はディスクから解析対象のファイルを取得しますが、
指定することでその情報を使って解析します。

** AST の捜査

コードを解析した結果は TranslationUnit を通して取得できます。

AST の格要素の情報は Cursor と呼ばれるオブジェクトで管理されています。

#+BEGIN_SRC Lua
local root = transUnit:getTranslationUnitCursor()
root:visitChildren( visitFuncMain, { depth = 0 } )
#+END_SRC

transUnit:getTranslationUnitCursor() で、 AST の Root Cursor を取得します。

なお、 Index、TranslationUnit、Cursor 等のオブジェクトは、
Lua の GC によって開放されます。

ここで次の点に関して注意する必要があります。

*「TranslationUnit のオブジェクトが Cursor オブジェクトよりも先に開放されてはならない」*


** 子要素の列挙

AST( Abstract Syntax Tree) は、その名の通りツリー構造になっています。

libclanglua では、 libclang の標準機能である再帰列挙方式と、
リスト取得方式を提供しています。

ツリーの階層構造を利用するには再起列挙方式の方が便利ですが、
ツリーの要素ごとに libclang と Lua 間を行き来するためオーバヘッドが大きくなり、
パフォーマンスが悪くなります。

一方でリスト取得方式では、
要素ごとではなくツリーの要素を全てリストに格納して一括処理するため、
オーバヘッドは少なくなります。
ただし、ツリーの要素全てをリストに格納するため、メモリを消費します。
なお、格納する要素の種別を指定することはできます。
また、リスト自体は libclanglua 内で制御するので、
リストの制御を意識する必要はありません。


*** 再起列挙方式

再起列挙方式では、root:visitChildren() を利用します。

root:visitChildren() の第 1 引数の visitFuncMain は、
子要素を列挙した際に呼ばれるコールバック関数です。

#+BEGIN_SRC Lua
local function visitFuncMain( cursor, parent, exInfo )
#+END_SRC

visitFuncMain() は 3 つの引数を持っています。

第 1 引数 cursor は、列挙された子要素の情報を保持する Cursor です。

第 2 引数 parent は、cursor の親の要素の情報を保持する Cursor です。

第 3 引数 exInfo は、visitFuncMain() の 第 2 引数で渡した値が入ります。


#+BEGIN_SRC Lua
local cursorKind = cursor:getCursorKind()
local txt = cursor:getCursorSpelling()
#+END_SRC

cursor:getCursorKind() は、その要素の種別を返します。
例えば 関数宣言 FunctionDecl, クラス宣言 ClassDecl などの宣言文や、
関数コール CallExpr、整数リテラル IntegerLiteral などの式などの種別があります。

cursor:getCursorSpelling() は、その要素のコード上の文字列表現です。

なお、 cursor に対してさらに cursor:visitChildren() を呼び出すことで、
子要素が列挙されます。

なお visitFuncMain() で返す値で、 visitChildren() の動作を制御します。

+ ~CXChildVisit_Break~ (0) を返すと以降の子要素の列挙はせず、
+ ~CXChildVisit_Continue~ (1) を返すと、現在の子要素と同じ階層の子要素の列挙を継続します。
+ ~CXChildVisit_Recurse~ (2) を指定すると、現在の子階層以降の要素の列挙します。

*** リスト取得方式

リスト取得方式では、
clang.visitChildrenFast( cursor, visitFuncMain, exInfo, nil, 1 )  を利用します。

第 1 引数〜第 3 引数までは、visitChildren() と同じです。

第 4 引数は、リストに格納する要素の CursorKind を指定するテーブルです。
nil の場合は、全ての CursorKind をリストに格納します。

第 5 引数は、リストに格納する要素を指定します。

+ ~CXChildVisit_Continue~ (1) を指定すると、 Cursor の直接の子階層の要素だけを格納します。
+ ~CXChildVisit_Recurse~ (2) を指定すると、Cursor の子階層以降の要素を全て格納します。


